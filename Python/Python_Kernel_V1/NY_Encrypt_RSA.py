#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#
# RSA
#   - 
#   - 
#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#

import random
import base64
import marshal

# ------------------------------------------------------------
# Euclidean Algorithm
# Input : a, b
# Output : 
# ------------------------------------------------------------
def __euclidean(a, b) :
    i = -1
    list_r = list()
    list_q = list()
    list_x = list()
    list_y = list()

    i += 1
    list_r.append(a)
    list_r.append(b)

    list_q.append(0)
    list_q.append(0)

    list_x.append(1)
    list_x.append(0)

    list_y.append(0)
    list_y.append(1)

    i = 2

    while 1 :
        list_r.append(list_r[i - 2] % list_r[i - 1])
        list_q.append(list_r[i - 2] // list_r[i - 1])

        if list_r[i] == 0 :
            d = list_r[i - 1]
            x = list_x[i - 1]
            y = list_y[i - 1]

            if x < 0 :
                x += b
            if y < 0 :
                y += b

            return d, x, y
        
        list_x.append(list_x[i - 2] - (list_q[i] * list_x[i - 1]))
        list_y.append(list_y[i - 2] - (list_q[i] * list_y[i - 1]))

        i += 1

# ------------------------------------------------------------
# Miller-Rabin Primality Test
# Input : n
# Output : 
# ------------------------------------------------------------
def __MR(n) :
    prime_impossible = 0
    prime_possible = 0

    def get_kq(number) :
        sub_k = 0
        sub_temp = number - 1
        binary_temp = bin(sub_temp)

        for sub_i in range(len(binary_temp) - 1, -1, -1) :
            if binary_temp[sub_i] == '0' :
                sub_k += 1
            else :
                break

        sub_q = sub_temp >> sub_k
        
        return sub_k, sub_q
    
    k, q = get_kq(n)

    if k == 0 :
        return 0
    
    for i in range(10) :
        a = int(random.uniform(2, n))

        if pow(a, q, n) == 1 :
            prime_possible += 1
            continue
        
        temp = 0
        for j in range(k) :
            if pow(a, (2 * j * q), n) == n - 1 :
                prime_possible += 1
                temp = 1
        
        if temp == 0 :
            prime_impossible += 1
            
    if prime_possible >= 6 :
        return 1

# ------------------------------------------------------------
# Create An Odd Number
# Input : bit_size
# Output : Odd Number
# ------------------------------------------------------------
def __create_odd(bit_size) :
    random.seed()

    bit = ''
    for i in range(bit_size - 1) :
        bit += str(int(random.uniform(1, 10)) % 2)
    
    bit += '1'

    return int(bit, 2)

# ------------------------------------------------------------
# Create A Prime Number
# Input : bit_size
# Output : Prime Number
# ------------------------------------------------------------
def __create_prime(bit_size) :
    while 1 :
        prime = __create_odd(bit_size)
        if __MR(prime) == 1 :
            return prime

# ------------------------------------------------------------
# [ Find e : Public ]
# 
# [ Find d : Private ]
#  
# Input : n
# Output : 
# ------------------------------------------------------------
def __get_ed(n) :
    while 1 :
        temp = int(random.uniform(2, 1000))
        d, x, y = __euclidean(temp, n)
        if d == 1 :
            return temp, x

# ------------------------------------------------------------
# from Value to String
# Input : value
# Output : string
# ------------------------------------------------------------
def __value_to_string(value) :
    result = ''
    for i in range(32) :
        byte = value & 0xff
        value >>= 8
        result += chr(byte) # Type Change : from Bytes to String

        if value == 0 :
            break
    
    return result

# ------------------------------------------------------------
# from String to Value
# Input : string
# Output : value
# ------------------------------------------------------------
def __string_to_value(string) :
    result = 0

    if isinstance(string, bytes) : # Type Case : Bytes
        for i in range(len(string)) :
            result |= string[i] << (i * 8) # Input : Bytes / Output : Bytes

    else : # Type Case : Not Bytes (String)
        for i in range(len(string)) :
            result |= ord(string[i]) << (i * 8) # Type Change : from String to Bytes
    
    return result

# ------------------------------------------------------------
# Create RSA Key
# Input : 
# Output : True / False
# ------------------------------------------------------------
def create_key(public_fName = 'key.public', private_fName = 'key.private', debug = False) :
    prime_p = __create_prime(128)
    prime_q = __create_prime(128)
    # print("Prime (P) : {p}".format(p = hex(prime_p)))
    # print("Prime (Q) : {q}".format(q = hex(prime_q)))

    modulus = prime_p * prime_q
    # print("Modulus : {m}".format(m = hex(modulus)))

    totient = (prime_p - 1) * (prime_q - 1)
    # print("Totient : {t}".format(t = hex(totient)))

    e, d = __get_ed(totient)
    # print("E : {e}".format(e = hex(e)))
    # print("D : {d}".format(d = hex(d)))

    public_key = [e, modulus]
    private_key = [d, modulus]
    """
    print()
    print("#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#")
    print("Public Key : {key}".format(key = public_key))
    print("Private Key : {key}".format(key = private_key))
    print("#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#")
    print()
    """

    public_key_data = base64.b64encode(marshal.dumps(public_key))
    private_key_data = base64.b64encode(marshal.dumps(private_key))

    # Create File : Public Key / Private Key
    try :
        open(public_fName, 'wb').write(public_key_data)
        open(private_fName, 'wb').write(private_key_data)
    
    except IOError :
        print("#### ERROR ####")
        return False

    if debug :
        print("[ Key File Create ] Result : Success")
        print("    - Public Key File : {file}".format(file = public_fName))
        print("    - Private Key File : {file}".format(file = private_fName))

    return True

# ------------------------------------------------------------
# Read RSA Key
# Input : 
# Output : RSA Key
# ------------------------------------------------------------
def read_key(key_fName) :
    try :
        with open(key_fName, 'rt') as fHandle :
            fBuf = fHandle.read()
            result = base64.b64decode(fBuf)
            key = marshal.loads(result)
        
        return key
    
    except IOError :
        return None

# ------------------------------------------------------------
# Encrypt / Decrypt
# Input : 
# Output : Result
# ------------------------------------------------------------
def crypt(target, key) :
    string_ord = __string_to_value(target)

    value = pow(string_ord, key[0], key[1])

    return __value_to_string(value)
